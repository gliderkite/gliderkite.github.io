<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.68.3" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>Learn Rust With Benford&#39;s Law&nbsp;&ndash;&nbsp;gliderkite.io</title><link rel="stylesheet" href="/css/core.min.fbccb1acab1cdfa1a69b4dacd7cf183c9bdb0cf812dd8d010803c1aabe273fcf9060d58a9c009152ede2f04dc6b5a2fc.css" integrity="sha384-&#43;8yxrKsc36Gmm02s188YPJvbDPgS3Y0BCAPBqr4nP8&#43;QYNWKnACRUu3i8E3GtaL8"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Learn Rust With Benford&#39;s Law" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><img class="site logo" src="/img/logo.png" alt /><span class="site name">gliderkite.io</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/microscopy">Microscopy</a><a class="nav item" href="/about">About</a></nav></div></span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">Learn Rust With Benford's Law</h1><p class="article date">Oct 17, 2020<span class="lastmod"> • edited Oct 09, 2022</span><span class="reading-time"> • 29 minutes to read</span></p></section><article class="article markdown-body"><p>When was the last time you read anything containing a significant amount of
non-randomly generated numbers?</p>
<p>What if I told you that the first digits of those numbers follow a well
defined frequency distribution, and that it would be possible to predict the
frequency of every single leading digit $[1-9]$ with good accuracy?</p>
<p>Sounds quite far-fetched, doesn&rsquo;t it? Well, this is exactly what I thought when
I learned about <a href="https://en.wikipedia.org/wiki/Benford%27s_law"target="_blank" rel="noopener noreferrer">Benford&rsquo;s law</a>
,
and that&rsquo;s when I decided to actually verify it.</p>
<p>I wasn&rsquo;t particularly interested in writing an introduction to Rust, as there
are already many and well written resources <a href="https://www.rust-lang.org/learn"target="_blank" rel="noopener noreferrer">out there</a>
. But, while I
was writing the code to check the above statements, I realized how nicely this
little project could work as a brief and practical introduction to the 
language, while also showing from a different angle <a href="https://stackoverflow.blog/2020/06/05/why-the-developers-who-use-rust-love-it-so-much/"target="_blank" rel="noopener noreferrer">why all the hype around it</a>
, and how does it actually feel to work with it.</p>
<p>And this was possible thanks to the fact that Benford&rsquo;s law is an observation that
can be very easily verified, and doing so allows us to touch not just different parts
of the Rust language itself, but also many of the important tools that come with it.</p>
<h3 id="prerequisites">Prerequisites</h3>
<p>Ideally you have a background in software engineering, or you are currently
studying computer science, and you are comfortable using the terminal. If this
is the first programming language you are trying to learn, I would suggest to
have a look at <a href="https://doc.rust-lang.org/book/"target="_blank" rel="noopener noreferrer">The Rust Book</a>
. You also ideally already have a basic
knowledge of the Rust primitive and compound <a href="https://doc.rust-lang.org/book/ch03-02-data-types.html"target="_blank" rel="noopener noreferrer">data types</a>
 and keywords
(reading the <a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29"target="_blank" rel="noopener noreferrer">Rust Wikipedia article</a>
 should give you all the information
you need to be able to follow this post).</p>
<h3 id="content">Content</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#the-benford-law">The Benford law</a>
</td>
</tr>
<tr>
<td><a href="#chapter-00---installing-rust">Chapter 00 - Installing Rust</a>
</td>
</tr>
<tr>
<td><a href="#chapter-01---setting-up-the-project">Chapter 01 - Setting up the Project</a>
</td>
</tr>
<tr>
<td><a href="#chapter-02---reading-the-dataset">Chapter 02 - Reading the Dataset</a>
</td>
</tr>
<tr>
<td><a href="#chapter-03---logging">Chapter 03 - Logging</a>
</td>
</tr>
<tr>
<td><a href="#chapter-04---parsing-the-dataset">Chapter 04 - Parsing the Dataset</a>
</td>
</tr>
<tr>
<td><a href="#chapter-05---comparing-results">Chapter 05 - Comparing Results</a>
</td>
</tr>
<tr>
<td><a href="#chapter-06---error-handling">Chapter 06 - Error Handling</a>
</td>
</tr>
<tr>
<td><a href="#chapter-07---command-line-arguments">Chapter 07 - Command Line Arguments</a>
</td>
</tr>
<tr>
<td><a href="#conclusions">Conclusions</a>
</td>
</tr>
</tbody>
</table>
<h2 id="the-benford-law">The Benford law</h2>
<p>From Wikipedia, Benford&rsquo;s law states that:</p>
<blockquote>
<p>In many naturally occurring collections of numbers, the leading digit is likely to be small.</p>
</blockquote>
<p>and it goes even further by giving the exact probability of each leading digit<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> 
that can be computed with the following formula:</p>
<p>$$p(digit) = log_{10} \left( 1 + \frac{1}{digit} \right)$$</p>
<p>Which can be nicely plotted as:</p>
<p><img  src="/img/benford/probabilities.png"
        alt="probabilities"/></p>
<p>This means, for example, that more than 30% of your numbers will start with <code>1</code>,
more than 17% will start with <code>2</code> and so on. It has been shown that these results
apply to a large variety of data sets, from population numbers, to stock prices,
to mathematical constants, and many others.</p>
<p>Now that we have enough context, we can start introducing Rust by writing a small
command line application that, given a set of numbers, will compute the frequency
of their leading digits, giving us the opportunity to verify how accurate
Benford&rsquo;s law is.</p>
<h2 id="chapter-00---installing-rust">Chapter 00 - Installing Rust</h2>
<p>The first thing to do is to <a href="https://www.rust-lang.org/tools/install"target="_blank" rel="noopener noreferrer">install Rust</a>
.</p>
<p>Once we have installed Rust, we can check what is the version of the compiler:</p>
<pre><code class="language-console" data-lang="console">$ rustc --version
rustc 1.47.0 (18bf6b4f0 2020-10-07)
</code></pre><p>If everything went well, we didn&rsquo;t just install the Rust compiler, but we can now
also use <a href="https://doc.rust-lang.org/cargo/"target="_blank" rel="noopener noreferrer">Cargo - The Rust package manager</a>
, which allows us to create, build,
and run any project, as well as to download all the project&rsquo;s dependencies.</p>
<p>You can find all the code of this post in the <a href="https://github.com/gliderkite/learn-rust-with-benford"target="_blank" rel="noopener noreferrer">learn-rust-with-benford repository</a>
.
The project there is organized in <a href="https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html"target="_blank" rel="noopener noreferrer">workspaces</a>
, so that you can run any of
the following chapters with (for example) the following command for the first
chapter:</p>
<pre><code class="language-console" data-lang="console">$ cargo run --package chapter01
</code></pre><h2 id="chapter-01---setting-up-the-project">Chapter 01 - Setting up the Project</h2>
<p>Let&rsquo;s create a new project called <code>benford</code>:</p>
<pre><code class="language-console" data-lang="console">$ cargo new benford
</code></pre><p>Cargo will create a new folder with the following structure:</p>
<pre><code>benford
├── Cargo.toml
├── src
│   ├── main.rs
</code></pre><p>The <code>Cargo.toml</code> file, is a <a href="https://en.wikipedia.org/wiki/TOML"target="_blank" rel="noopener noreferrer">TOML</a>
 file, where we can specify our package
name and version, and the project&rsquo;s external dependencies (currently none):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-toml" data-lang="toml">[<span style="color:#a6e22e">package</span>]
<span style="color:#a6e22e">name</span> = <span style="color:#e6db74">&#34;benford&#34;</span>
<span style="color:#a6e22e">version</span> = <span style="color:#e6db74">&#34;0.1.0&#34;</span>
<span style="color:#a6e22e">authors</span> = [<span style="color:#e6db74">&#34;gliderkite &lt;gliderkite@gmail.com&gt;&#34;</span>]
<span style="color:#a6e22e">edition</span> = <span style="color:#e6db74">&#34;2018&#34;</span>

[<span style="color:#a6e22e">dependencies</span>]
</code></pre></div><p>While <code>main.rs</code> is the source code file that contains the entry point of our
application:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Hello, world!&#34;</span>);
}
</code></pre></div><p>Where <code>println!</code> is just a <a href="https://doc.rust-lang.org/book/ch19-06-macros.html"target="_blank" rel="noopener noreferrer">function-like macro</a>
 that prints formatted
strings to the standard output.</p>
<p>Let&rsquo;s compile and run the project for the first time; we can build it with
<code>cargo build</code> or simply build and run with <code>cargo run</code><sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>:</p>
<pre><code class="language-console" data-lang="console">$ cargo run
    Compiling benford v0.1.0
    Finished dev [unoptimized + debuginfo] target(s) in 0.15s
        Running `target/debug/benford`
Hello, world!
</code></pre><p>Another important command that we are going to use without mentioning throughout
the whole post is <a href="https://github.com/rust-lang/rustfmt"target="_blank" rel="noopener noreferrer"><code>cargo fmt</code></a>
: a tool for automatically formatting Rust
code according to style guidelines.</p>
<h2 id="chapter-02---reading-the-dataset">Chapter 02 - Reading the Dataset</h2>
<p>For our little experiment, we need a set of <em>real-life</em> numbers, and I thought
I could simply use the <a href="https://en.wikipedia.org/wiki/Census"target="_blank" rel="noopener noreferrer">population census</a>
 of my country, since it&rsquo;s
publicly available information, it&rsquo;s not randomly generated data, it contains a
relatively large set of numbers (in this example just above 8000), and it&rsquo;s
relatively simple to retrieve (you should try with the census of your own
country and compare the results!).</p>
<p>This type of data is usually encoded in text files as tables, such as Excel
spreadsheets, so it&rsquo;s easy to export into <a href="https://en.wikipedia.org/wiki/Comma-separated_values"target="_blank" rel="noopener noreferrer">CSV</a>
, and that is exactly the
format we are going to use for our input. The content of the file (census.csv)
looks like this:</p>
<pre><code class="language-csv" data-lang="csv">City,Population
Agliè,2608
Airasca,3790
Ala di Stura,435
Albiano d'Ivrea,1847
Alice Superiore,694
Almese,6173
Alpette,267
Alpignano,16817

...
</code></pre><p>Where the first column is the name of the town, and the second (and last) column
is its population (at the time of the census).</p>
<p>We could parse this text file by simply using filesystem and string utilities,
but let&rsquo;s instead introduce one of the most powerful tools we have at our disposal:
dependencies management.</p>
<p>Most of the publicly available Rust packages (called <em>crates</em>) can be found on
<a href="https://crates.io/"target="_blank" rel="noopener noreferrer">crates.io - The Rust crate registry</a>
, which is a large repository of all the
packages different developers made available to the community, and it happens
to contain the library we need to parse CSV files, which (surprise, surprise) was
named <a href="https://crates.io/crates/csv"target="_blank" rel="noopener noreferrer">csv</a>
.</p>
<p>To add a dependency to our project, we just need to add the dependency name, with
the version we chose, to our list of dependencies in the <code>Cargo.toml</code> file:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-toml" data-lang="toml">[<span style="color:#a6e22e">dependencies</span>]
<span style="color:#a6e22e">csv</span> = <span style="color:#e6db74">&#34;1.1.3&#34;</span>
</code></pre></div><p>But how do we actually know what types and functions are provided by this library,
and how do we use them? This is were <a href="https://docs.rs/"target="_blank" rel="noopener noreferrer">docs.rs - The Rust documentation host</a>

comes to help, it&rsquo;s the place where you can find all the documentation of all the
packages hosted on <a href="https://crates.io/"target="_blank" rel="noopener noreferrer">crates.io</a>
, and we can start by having a look at the
<a href="https://docs.rs/csv/1.1.3/csv/"target="_blank" rel="noopener noreferrer">csv library documentation</a>
.</p>
<p>The first thing we want to do is probably learn how to read a CSV file by
using this library. If we look at the list of examples in the library
documentation, we can quickly find the example we need, which shows how the
<a href="https://docs.rs/csv/1.1.3/csv/struct.Reader.html#method.from_reader"target="_blank" rel="noopener noreferrer"><code>csv::Reader::from_reader(reader: impl Read)</code></a>

method creates a new CSV parser for the given <code>reader</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> csv_reader <span style="color:#f92672">=</span> csv::Reader::from_reader(reader);
</code></pre></div><p>Notice how, even though Rust is a statically typed language, we didn&rsquo;t have to
specify the type of <code>csv_reader</code>, since most of the times the compiler will
be able to <a href="https://en.wikipedia.org/wiki/Type_inference"target="_blank" rel="noopener noreferrer">infer the type</a>
 of the variables for us.</p>
<p>The argument <code>reader</code> needs to implement the <code>Read</code> <a href="https://doc.rust-lang.org/book/ch10-02-traits.html"target="_blank" rel="noopener noreferrer">trait</a>
 (traits are a
way to share behaviors between different types - often called <em>interfaces</em> in
other programming languages), which allows for reading bytes from a source.</p>
<p>In our case, the source will be the CSV file with the census data, which means we
need to create a new <code>File</code> object that implements the above mentioned <code>Read</code>
trait.</p>
<p>We can find this type in the Rust standard library that, among many other things,
also exports the types and functions that allow us to work with the filesystem, and,
as we have seen for the <code>csv</code> library, also comes with its own <a href="https://doc.rust-lang.org/std/index.html"target="_blank" rel="noopener noreferrer">std documentation</a>
,
where we can search and find the <a href="https://doc.rust-lang.org/std/fs/struct.File.html"target="_blank" rel="noopener noreferrer">File type</a>
 we were looking for<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>.</p>
<p>Let&rsquo;s proceed to create the CSV reader that is going to be used to read
and iterate over the census data:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::fs;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> dataset <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;census.csv&#34;</span>;
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Reading dataset from {}&#34;</span>, dataset);
    <span style="color:#66d9ef">let</span> file <span style="color:#f92672">=</span> fs::File::open(dataset).expect(<span style="color:#e6db74">&#34;Cannot read dataset&#34;</span>);
    <span style="color:#66d9ef">let</span> reader <span style="color:#f92672">=</span> csv::Reader::from_reader(file);
}
</code></pre></div><p>and if we compile<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup> the project, we get:</p>
<pre><code class="language-console" data-lang="console">$ cargo build
warning: unused variable: `reader`
 --&gt; src/main.rs:6:9
  |
6 |     let reader = csv::Reader::from_reader(file);
  |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_reader`
  |
  = note: `#[warn(unused_variables)]` on by default
</code></pre><p>You have now met the compiler, the reason why many Rust developers talk about pair
programming when working with Rust: its warnings and error messages are extremely
useful (and you will most likely encounter many thanks to the <a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html"target="_blank" rel="noopener noreferrer">borrow checker</a>
<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>).</p>
<p>One important thing to point out at this point is the <code>.expect()</code> method we used
when opening the file:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> file <span style="color:#f92672">=</span> fs::File::open(dataset).expect(<span style="color:#e6db74">&#34;Cannot read dataset&#34;</span>);
</code></pre></div><p>The truth is that many operations can fail, and in Rust there are two main ways
to handle errors:</p>
<ul>
<li>Calling the function-like macro <a href="https://doc.rust-lang.org/std/macro.panic.html"target="_blank" rel="noopener noreferrer"><code>panic!</code></a>
 when the error is not recoverable,
which will print an error message (optionally showing the backtrace), unwind the stack, and terminate the program.</li>
<li>Return the outcome of an operation with the <a href="https://doc.rust-lang.org/std/result/enum.Result.html"target="_blank" rel="noopener noreferrer"><code>Result</code> enum</a>
 that either
contains the outcome of a successful operation in its <code>Ok(Type)</code> variant, or
it contains the information of the error, in its <code>Err(ErrorType)</code> variant, 
which can be propagated and handled when most appropriate.</li>
</ul>
<p>The easiest way to handle errors, especially when writing examples, is probably to
<code>panic!</code>, and this is exactly what our code does: if the file cannot be opened
for any reason, <code>.expect()</code> will simply call internally <code>panic!</code> with the given
error message and terminate the program, otherwise it will <em>unwrap</em> the content
of the <code>Result::Ok(Type)</code> variant (now stored in the variable <code>file</code>). This is
what happens for example if the census file doesn&rsquo;t exist:</p>
<pre><code class="language-console" data-lang="console">$ cargo run
thread 'main' panicked at 'Cannot read dataset: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }', src/main.rs:5:40
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre><p>We will come back to show how to handle recoverable errors with <code>Result</code> in a
following chapter.</p>
<p>Now that we have a CSV reader, we can use it to iterate over all the
records/towns in the file, and extract from each record the value representing
the population.</p>
<p>From the <code>csv</code> library documentation, we can see how to iterate over all the records
by using the <a href="https://docs.rs/csv/1.1.3/csv/struct.Reader.html#method.records"target="_blank" rel="noopener noreferrer"><code>csv::Reader::records()</code></a>
 method:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> reader <span style="color:#f92672">=</span> csv::Reader::from_reader(file);

println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Parsing CSV records&#34;</span>);
<span style="color:#66d9ef">for</span> record <span style="color:#66d9ef">in</span> reader.records() {
    <span style="color:#75715e">// record is a Result that we must unwrap before parsing its content
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> record <span style="color:#f92672">=</span> record.expect(<span style="color:#e6db74">&#34;Invalid record&#34;</span>);
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:?}&#34;</span>, record);
}
</code></pre></div><p>You can see how each record is actually wrapped in a
<code>Result&lt;csv::StringRecord, csv::Error&gt;</code> (since there may be records with invalid
format in the file).
For this reason, we need to unwrap it with <code>.expect()</code> to get its
<code>csv::StringRecord</code> if the record is valid, like we&rsquo;ve done before when opening 
the  <code>File</code> (or <code>panic!</code> when it&rsquo;s not valid and the <code>Result</code> contains an <code>Error</code>).</p>
<p>Notice also how the variable name <code>record</code> after the unwrapping is the same as
the one declared in the <code>for</code> loop. This is possible because Rust allows
<a href="https://en.wikipedia.org/wiki/Variable_shadowing"target="_blank" rel="noopener noreferrer">variable shadowing</a>
 (in this particular case the outer variable declared in
the loop will be <em>shadowed</em> by the inner variable declared within it).</p>
<p>However, the above code will not compile; let&rsquo;s see why by looking at the error message:</p>
<pre><code>error[E0596]: cannot borrow `reader` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:8:18
  |
6 |     let reader = csv::Reader::from_reader(file);
  |         ------ help: consider changing this to be mutable: `mut reader`
7 | 
8 |     for record in reader.records() {
  |                   ^^^^^^ cannot borrow as mutable
</code></pre><p>As you can see, the reason why we cannot compile this code is because the method
we are trying to use (<a href="https://docs.rs/csv/1.1.3/csv/struct.Reader.html#method.records"target="_blank" rel="noopener noreferrer"><code>csv::Reader::records(&amp;mut self)</code></a>
) requires us to
<em>mutably borrow</em> our instance of <code>Reader</code> (this is what <code>&amp;mut self</code> means - if
the method needed to <em>immutably borrow</em>, we would have found it written as <code>&amp;self</code>),
and by default all declared variables in Rust are <em>immutable</em>.</p>
<p>As the compiler is suggesting, we simply need to declare the <code>reader</code> variable
mutable by adding <code>mut</code> in front of the variable name to fix our code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> reader <span style="color:#f92672">=</span> csv::Reader::from_reader(file);
</code></pre></div><p>We can now iterate over all the towns, but what exactly are we printing when
using the macro <code>println!(&quot;{:?}&quot;, record)</code>?</p>
<p>This is another important feature of Rust that enables easier debugging by
automatically implementing the debug string representation of a type, when
deriving the <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"target="_blank" rel="noopener noreferrer">Debug trait</a>
. As a classic example, suppose you have a <code>Point</code>
structure with integer (32 bits) abscissa and ordinate fields:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span> {
    x: <span style="color:#66d9ef">i32</span>,
    y: <span style="color:#66d9ef">i32</span>,
}

<span style="color:#66d9ef">let</span> origin <span style="color:#f92672">=</span> Point { x: <span style="color:#ae81ff">0</span>, y: <span style="color:#ae81ff">0</span> };
</code></pre></div><p>If you would like to print the value of your point to the standard output, the
only thing you need to do is to derive the <code>Debug</code> trait with a 
<a href="https://doc.rust-lang.org/reference/procedural-macros.html"target="_blank" rel="noopener noreferrer">procedural derive macro</a>
, to be able to use the <code>{:?}</code> syntax:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[derive(Debug)]</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span> {
    x: <span style="color:#66d9ef">i32</span>,
    y: <span style="color:#66d9ef">i32</span>,
}

println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:?}&#34;</span>, origin);
</code></pre></div><pre><code class="language-console" data-lang="console">Point { x: 0, y: 0 }
</code></pre><p>And you can also enable pretty-printing with a slightly different syntax:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:#?}&#34;</span>, origin);
</code></pre></div><pre><code class="language-console" data-lang="console">Point {
    x: 0,
    y: 0,
}
</code></pre><p>Coming back to our example, we can finally start to see all the file records
being printed to the standard output when we run the project:</p>
<pre><code class="language-console" data-lang="console">$ cargo run
Parsing CSV records
StringRecord([&quot;Agliè&quot;, &quot;2608&quot;])
StringRecord([&quot;Airasca&quot;, &quot;3790&quot;])
StringRecord([&quot;Ala di Stura&quot;, &quot;435&quot;])
StringRecord([&quot;Albiano d\'Ivrea&quot;, &quot;1847&quot;])
StringRecord([&quot;Alice Superiore&quot;, &quot;694&quot;])
StringRecord([&quot;Almese&quot;, &quot;6173&quot;])
StringRecord([&quot;Alpette&quot;, &quot;267&quot;])
StringRecord([&quot;Alpignano&quot;, &quot;16817&quot;])

...
</code></pre><h2 id="chapter-03---logging">Chapter 03 - Logging</h2>
<p>We ended <a href="#chapter-02---reading-the-dataset">the second chapter</a>
 by printing
all the cities in the census file to the standard output, and that is quite a lot
of output. Let&rsquo;s see if we can better handle the information we decide to display
to stdout.</p>
<p>Usually, we have to deal with different kinds of information, and each information
could be associated to how important it is and therefore in what situations we
want to display it. This is where logging can help, even when just redirecting
output to stdout.</p>
<p>What we need is a logging <em>facade</em> (that offers an abstraction to the
logging APIs we are going to use) and an implementation. These can be found
respectively in the <a href="https://docs.rs/log/0.4.11/log/"target="_blank" rel="noopener noreferrer"><code>log</code> crate</a>
 and in the <a href="https://docs.rs/env_logger/0.8.1/env_logger/index.html"target="_blank" rel="noopener noreferrer"><code>env_logger</code> crate</a>
 (but
there are several other implementations that you are free to try out).</p>
<p>As we have done for the <code>csv</code> library, the first thing to do is to import them
as new dependencies in our <code>Cargo.toml</code> file:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-toml" data-lang="toml">[<span style="color:#a6e22e">dependencies</span>]
<span style="color:#a6e22e">csv</span> = <span style="color:#e6db74">&#34;1.1.3&#34;</span>
<span style="color:#a6e22e">env_logger</span> = <span style="color:#e6db74">&#34;0.8.1&#34;</span>
<span style="color:#a6e22e">log</span> = <span style="color:#e6db74">&#34;0.4.11&#34;</span>
</code></pre></div><p>Using a logger is relatively simple, we just need to initialize the logger
implementation and then use the various log APIs provided by the facade
according to the level we need (trace, debug, info, warn, or error):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// initialize the logger implementation
</span><span style="color:#75715e"></span>    env_logger::init();

    <span style="color:#66d9ef">let</span> dataset <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;census.csv&#34;</span>;
    log::info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Reading dataset from {}&#34;</span>, dataset);
    <span style="color:#66d9ef">let</span> file <span style="color:#f92672">=</span> fs::File::open(dataset).expect(<span style="color:#e6db74">&#34;Cannot read dataset&#34;</span>);
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> reader <span style="color:#f92672">=</span> csv::Reader::from_reader(file);

    log::info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Parsing CSV records&#34;</span>);
    <span style="color:#66d9ef">for</span> record <span style="color:#66d9ef">in</span> reader.records() {
        <span style="color:#66d9ef">let</span> record <span style="color:#f92672">=</span> record.expect(<span style="color:#e6db74">&#34;Invalid record&#34;</span>);
        log::trace<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:?}&#34;</span>, record);
    }
}
</code></pre></div><p>As you can see, we have just replaced the <code>println!</code> macros with <code>log::info!</code> or
<code>log::trace!</code> macros according to the level of logging we find the most
appropriate. And we can enable different level of logging by setting the
environment variable <code>RUST_LOG</code>, for example:</p>
<pre><code class="language-console" data-lang="console">$ RUST_LOG=info cargo run
[2020-10-04T12:17:45Z INFO  benford] Reading dataset from census.csv
[2020-10-04T12:17:45Z INFO  benford] Parsing CSV records
</code></pre><p>While setting <code>RUST_LOG=trace</code> would also print all the file records.</p>
<h2 id="chapter-04---parsing-the-dataset">Chapter 04 - Parsing the Dataset</h2>
<p>The next step involves extracting the information we need from each record (i.e.
the population value) and building the frequency map of the leading digits.</p>
<p>As we have seen, iterating over the file records yields a list of
<a href="https://docs.rs/csv/1.1.3/csv/struct.StringRecord.html"target="_blank" rel="noopener noreferrer"><code>csv::StringRecord</code>s</a>
, and we need to extract the population value, which
corresponds to the second column of our dataset. We can achieve this by using
the <a href="https://docs.rs/csv/1.1.3/csv/struct.StringRecord.html#method.get"target="_blank" rel="noopener noreferrer"><code>csv::StringRecord::get()</code></a>
 method:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">for</span> record <span style="color:#66d9ef">in</span> reader.records() {
    <span style="color:#66d9ef">let</span> record <span style="color:#f92672">=</span> record.expect(<span style="color:#e6db74">&#34;Invalid record&#34;</span>);

    <span style="color:#66d9ef">let</span> city <span style="color:#f92672">=</span> record.get(<span style="color:#ae81ff">0</span>);
    <span style="color:#66d9ef">let</span> population <span style="color:#f92672">=</span> record.get(<span style="color:#ae81ff">1</span>);
    log::trace<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:?} population: {:?}&#34;</span>, city, population);
}
</code></pre></div><p>And if we run the project, we&rsquo;ll see something similar to:</p>
<pre><code class="language-console" data-lang="console">$ RUST_LOG=trace cargo run
[INFO] Reading dataset from census.csv
[INFO] Parsing CSV records
[TRACE] Some(&quot;Agliè&quot;) population: Some(&quot;2608&quot;)
[TRACE] Some(&quot;Airasca&quot;) population: Some(&quot;3790&quot;)

...
</code></pre><p>From this output, it looks like we are not just dealing with strings; in fact, as
you can see, these are wrapped in a type which <code>Debug</code> representation is, for
example, <code>Some(&quot;Airasca&quot;)</code> or <code>Some(&quot;3790&quot;)</code>.</p>
<p>You are now meeting what is, with <code>Result</code>, possibly the most important enum in
Rust: <a href="https://doc.rust-lang.org/std/option/enum.Option.html"target="_blank" rel="noopener noreferrer"><code>Option</code></a>
. The <code>Option</code> type, as the name suggests,
represents an optional type, and it can be either <code>Some(Type)</code> or <code>None</code>, and
the Rust type system allows us to know at compile time whether the option can be
unwrapped while safely getting its content, or if instead it does not contain
anything. And this feature helps to prevent a class of bugs that in other languages
is related to the <a href="https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions"target="_blank" rel="noopener noreferrer">billion dollar mistake</a>
 (where the type system includes
null references or null pointers).</p>
<p>In order to use an <code>Option</code>, we can introduce another important feature of Rust:
<a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html"target="_blank" rel="noopener noreferrer">pattern matching</a>
. Basically, what we need is to match the value of the
<code>Option</code> that represents the city population with a pattern that can be either
<code>Some(population)</code> when the CSV record contains a second column, or <code>None</code> when
it doesn&rsquo;t (which should never happen if our input is correct). To do so, we can
use the Rust keyword <code>match</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">for</span> record <span style="color:#66d9ef">in</span> reader.records() {
    <span style="color:#66d9ef">let</span> record <span style="color:#f92672">=</span> record.expect(<span style="color:#e6db74">&#34;Invalid record&#34;</span>);

    <span style="color:#66d9ef">match</span> record.get(<span style="color:#ae81ff">1</span>) {
        Some(population) <span style="color:#f92672">=&gt;</span> log::trace<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Population: {}&#34;</span>, population),
        None <span style="color:#f92672">=&gt;</span> log::warn<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;No population value!&#34;</span>),
    };
}
</code></pre></div><pre><code class="language-console" data-lang="console">$ RUST_LOG=trace cargo run
[INFO] Reading dataset from census.csv
[INFO] Parsing CSV records
[TRACE] Population: 2608
[TRACE] Population: 3790

...
</code></pre><p>We can now finally build the frequency map, where the keys of the map will be
all the possible digits $[1-9]$, while the values will be the frequency these
digits appear as the first digit of the population values.</p>
<p>The only choice we need to make is if we want to deal with these numbers as
actual integers or keep them as they are currently represented as strings. Either
choice is fine for the sake of this tutorial, so we are going to continue with
the strings we currently have, to avoid the conversions (but you are free to try
changing the code using integers instead).</p>
<p><a href="https://doc.rust-lang.org/book/ch08-02-strings.html"target="_blank" rel="noopener noreferrer">Dealing with strings in Rust is not straightforward</a>
, and this is essentially
because dealing with strings in general is not straightforward; it just happens
that many other programming languages made the choice of hiding this complexity
from the user.
Fortunately, what we need to do is not too complex: we need to get the first digit
of the population value, that is (being the population value a string), we need
to extract its first character.</p>
<p>If we try with:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> digit <span style="color:#f92672">=</span> population[<span style="color:#ae81ff">0</span>];
</code></pre></div><p>We would just get the following error:</p>
<pre><code>  --&gt; src/main.rs:20:29
   |
20 |                 let digit = population[0];
   |                             ^^^^^^^^^^^^^ string indices are ranges of `usize`
   |
   = help: the trait `std::slice::SliceIndex&lt;str&gt;` is not implemented for `{integer}`
   = note: you can use `.chars().nth()` or `.bytes().nth()`
           see chapter in The Book &lt;https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings&gt;
   = note: required because of the requirements on the impl of `std::ops::Index&lt;{integer}&gt;` for `str`
</code></pre><p>Fortunately the error message is very helpful; it shows a link to the Rust book
with a nice explanation on why indexing strings is not possible, but also a
couple of solutions that we can use to fix this problem. There is also a third
option, which is semantically equivalent, and that&rsquo;s what we are going to use:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// get the first character of the population (represented as string)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> digit <span style="color:#f92672">=</span> population.chars().next();
</code></pre></div><p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next"target="_blank" rel="noopener noreferrer">If you look closely</a>
, you&rsquo;ll see that <code>digit</code> is not exactly a character, but
it&rsquo;s a character wrapped in an <code>Option</code>, since the <code>population</code> may be an empty
string and the first character may not even exist, and therefore we are forced
to deal with this scenario as we did previously with the population record.</p>
<p>But our loop logic is starting to become more difficult to follow, and it would
get worse if we started adding another pattern matching. Maybe we could extract
part of the logic into a separate function that, given an immutable reference to
a valid record, would optionally return the first digit of the population value
as character.</p>
<p>This is what a possible implementation could look like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_first_digit</span>(record: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">csv</span>::StringRecord) -&gt; Option<span style="color:#f92672">&lt;</span>char<span style="color:#f92672">&gt;</span> {
    log::trace<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Parsing record: {:?}&#34;</span>, record);
    <span style="color:#66d9ef">match</span> record.get(<span style="color:#ae81ff">1</span>) {
        Some(population) <span style="color:#f92672">=&gt;</span> population.chars().next(),
        None <span style="color:#f92672">=&gt;</span> None,
    }
}
</code></pre></div><p>If you notice, we only return <code>Some(char)</code> when we both have a population in the
record and the population contains a first character (in any other case this
function will return <code>None</code>). We can try to improve this implementation, and if
you read the <a href="https://doc.rust-lang.org/std/option/enum.Option.html"target="_blank" rel="noopener noreferrer"><code>Option</code> documentation</a>
 you will notice there are several
utility methods we could use to make the implementation less verbose by replacing
the pattern matching with the semantically equivalent <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.and_then"target="_blank" rel="noopener noreferrer"><code>Option::and_then</code></a>

combinator:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">record
    .get(<span style="color:#ae81ff">1</span>)
    .and_then(<span style="color:#f92672">|</span>population<span style="color:#f92672">|</span> population.chars().next())
</code></pre></div><p>If you are wondering about the syntax inside the <code>and_then</code> combinator, this is
how you define <a href="https://en.wikipedia.org/wiki/Closure_%28computer_programming%29"target="_blank" rel="noopener noreferrer">closures</a>
 in Rust, which are basically anonymous functions
that can capture the environment. And in this case, the closure accepts a string
as the only input (the <code>population</code>) and returns an <code>Option</code> that wraps a
character.</p>
<p>But how do we know that the character we are returning, when the <code>Option</code> contains 
<code>Some(char)</code>, will actually be a valid digit between 1 and 9? If our population 
record contains invalid data, such as <code>abc-xyz</code>, this method would return the 
character <code>a</code>.</p>
<p>To solve this issue, we can simply chain another <code>Option</code> combinator, to filter
only valid characters:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">record
    .get(<span style="color:#ae81ff">1</span>)
    .and_then(<span style="color:#f92672">|</span>population<span style="color:#f92672">|</span> population.chars().next())
    .filter(<span style="color:#f92672">|</span>c<span style="color:#f92672">|</span> c.is_ascii_digit() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>c <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;0&#39;</span>)
</code></pre></div><p>As you can see in the last step, we use the <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.filter"target="_blank" rel="noopener noreferrer"><code>Option::filter</code></a>
 method to
keep every character that is an ASCII digit $[0-9]$, but since our numbers can
only start with $[1-9]$ we need to take that into account and remove any possible
string starting with the character <code>'0'</code>. If these conditions are not satisfied,
our new function will simply return <code>None</code>, as if no digit was found for the
given record.</p>
<p>If you find the syntax <code>*c != '0'</code> odd, you just need to know that the <code>filter</code>
closure input <code>c</code> is a reference to a character, and therefore it needs to be
<a href="https://en.wikipedia.org/wiki/Dereference_operator"target="_blank" rel="noopener noreferrer">dereferenced</a>
 before being compared to another character.</p>
<p>Now we can match the <code>Option</code> returned by this function in our loop, and we can
do so by introducing an alternative but equivalent syntax to <code>match</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">for</span> record <span style="color:#66d9ef">in</span> reader.records() {
    <span style="color:#66d9ef">let</span> record <span style="color:#f92672">=</span> record.expect(<span style="color:#e6db74">&#34;Invalid record&#34;</span>);

    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(digit) <span style="color:#f92672">=</span> get_first_digit(<span style="color:#f92672">&amp;</span>record) {
        log::trace<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Found digit &#39;{}&#39; in {:?}&#34;</span>, digit, record);
    } <span style="color:#66d9ef">else</span> {
        log::warn<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;No valid digit found in {:?}&#34;</span>, record);
    }
}
</code></pre></div><pre><code class="language-console" data-lang="console">$ RUST_LOG=trace cargo run
[INFO] Reading dataset from census.csv
[INFO] Parsing CSV records
[TRACE] Parsing record: StringRecord([&quot;Agliè&quot;, &quot;2608&quot;])
[TRACE] Found digit '2' in StringRecord([&quot;Agliè&quot;, &quot;2608&quot;])
[TRACE] Parsing record: StringRecord([&quot;Airasca&quot;, &quot;3790&quot;])
[TRACE] Found digit '3' in StringRecord([&quot;Airasca&quot;, &quot;3790&quot;])

...
</code></pre><p>The only missing part is to create the frequency map according to the digits
found.</p>
<p>What we need is an associative array; for that, the obvious choice would
be a <a href="https://en.wikipedia.org/wiki/Hash_table"target="_blank" rel="noopener noreferrer">hash table</a>
 since it would have ideal time complexity, and we can
find a hash table implementation in the Rust standard library under the
<a href="https://doc.rust-lang.org/beta/std/collections/struct.HashMap.html"target="_blank" rel="noopener noreferrer"><code>HashMap</code> type</a>
. The keys of our map will be the digits $[1-9]$ as we
parse them (i.e. as characters), while the values will be integer values that
correspond to how many times we found that leading digit in the records.</p>
<p>We can now proceed and fill up the frequency map:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::collections::HashMap;

<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> frequency <span style="color:#f92672">=</span> HashMap::new();

<span style="color:#66d9ef">for</span> record <span style="color:#66d9ef">in</span> reader.records() {
    <span style="color:#66d9ef">let</span> record <span style="color:#f92672">=</span> record.expect(<span style="color:#e6db74">&#34;Invalid record&#34;</span>);

    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(digit) <span style="color:#f92672">=</span> get_first_digit(record) {
        <span style="color:#75715e">// find the value corresponding to the digit key or insert a new
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// entry with an initial value of 0
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> count <span style="color:#f92672">=</span> frequency.entry(digit).or_insert(<span style="color:#ae81ff">0</span>);
        <span style="color:#75715e">// count is a mutable reference to the value in the HashMap
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// increment its value by 1 after dereferencing it
</span><span style="color:#75715e"></span>        <span style="color:#f92672">*</span>count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
    }
}

log::debug<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Frequency: {:?}&#34;</span>, frequency);
</code></pre></div><p>As you can see, we were able to skip the initialization of the <code>HashMap</code> (that
could have been initialized with all zeros values for each key digit - as to
represent and empty census file), and rely on our <code>get_first_digit</code> function, which
returns <code>Some(digit)</code> only if the parsed <code>record</code> is valid.</p>
<p>Once we have a valid digit, we query the frequency map to get the current value
representing how many times we already encountered it, and increment its
value (<code>count</code>) by 1.
If the digit we are trying to use as key doesn&rsquo;t belong yet to the frequency map,
a new entry will be created with an initial value equal to 0.</p>
<pre><code class="language-console" data-lang="console">$ RUST_LOG=debug cargo run
[INFO] Reading dataset from census.csv
[INFO] Parsing CSV records
[DEBUG] Frequency: {'2': 1395, '7': 455, '4': 745, '1': 2486, '9': 362, '8': 449, '6': 550, '3': 1007, '5': 643}
</code></pre><p>Are these values starting to look familiar?</p>
<h2 id="chapter-05---comparing-results">Chapter 05 - Comparing Results</h2>
<p>We ended <a href="#chapter-04---parsing-the-dataset">the previous chapter</a>
 with a
frequency map of our digits that looks like this:</p>
<pre><code class="language-console" data-lang="console">Frequency: {
    '2': 1395,
    '3': 1007,
    '5': 643,
    '6': 550,
    '4': 745,
    '8': 449,
    '9': 362,
    '1': 2486,
    '7': 455,
}
</code></pre><p>But these are just the raw frequencies of the first digits; what we would like
is instead the percentages in which these digits appear and, ideally, they would be
sorted by digit from 1 to 9. There are many ways to achieve this; one way is
to store our final results into a different data structure where keys are
sorted: in Rust, you can find this data structure under the <a href="https://doc.rust-lang.org/beta/std/collections/struct.BTreeMap.html"target="_blank" rel="noopener noreferrer"><code>BTreeMap</code> type</a>
.</p>
<p>The keys of the new map are always going to be all the (sorted) digits $[1-9]$ as
characters, while the values will be floating point numbers representing the
percentage of how often they appear.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> total: <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> frequency.values().sum();
<span style="color:#66d9ef">let</span> percentage: <span style="color:#a6e22e">BTreeMap</span><span style="color:#f92672">&lt;</span>char, <span style="color:#66d9ef">f32</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> frequency
    .into_iter()
    .map(<span style="color:#f92672">|</span>(digit, count)<span style="color:#f92672">|</span> (digit, count <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f32</span> <span style="color:#f92672">/</span> total <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f32</span>))
    .collect();

log::info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Percentage: {:#.2?}&#34;</span>, percentage);
</code></pre></div><p>What happens in the above code is that, after we compute the sum of all the
frequency values (i.e. how many total digits we encountered), we create a new
<code>BTreeMap</code> by iterating over all the key-value pairs of our frequency map and,
for each of these, we keep the <code>digit</code> as is while the value <code>count</code> is mapped to
its respective percentage, to then finally collect all the new key-value pairs
into the new data structure.</p>
<p>And, believe it or not, this is what we get:</p>
<pre><code class="language-console" data-lang="console">Percentage: {
    '1': 0.31,
    '2': 0.17,
    '3': 0.12,
    '4': 0.09,
    '5': 0.08,
    '6': 0.07,
    '7': 0.06,
    '8': 0.06,
    '9': 0.04,
}
</code></pre><p>Let&rsquo;s compare it with the expected values (the blue bars represent the expected
values, while the red ones represent the results we got from the census file):</p>
<p><img  src="/img/benford/probabilities-delta.png"
        alt="delta"/></p>
<h2 id="chapter-06---error-handling">Chapter 06 - Error Handling</h2>
<p>In <a href="#chapter-02---reading-the-dataset">Chapter 02</a>
, we saw how we
decided to simply terminate the program in some of the cases where we could
encounter an error, independently if we could actually recover from it or not.</p>
<p>There may be situations in which terminating the whole program is a valid
solution; for example, when the census file doesn&rsquo;t exist, there is
very little we can do. We can consider the existence of the input file as an
invariant that must hold no matter what, and if it doesn&rsquo;t, there is no point
for our program to run. In such situations, <code>panic!</code> is a valid compromise.</p>
<p>Nevertheless, we should try to recover whenever possible and, depending on our
logic, we can try to implement a different mechanism for error handling that
would fit better the expectations of our application.</p>
<p>For example, let&rsquo;s consider what happens when we have managed to open the file,
but we can&rsquo;t parse a specific record:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// record is a Result that we must unwrap before parsing its content
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> record <span style="color:#f92672">=</span> record.expect(<span style="color:#e6db74">&#34;Invalid record&#34;</span>);
</code></pre></div><p>With our current implementation, if the record is not valid, the program will
terminate. Let&rsquo;s assume instead that discarding an invalid record is a valid
choice.</p>
<p>A first way to check whether the record is valid or not is to use pattern matching, as we&rsquo;ve seen before for similar situations. If you remember, <code>record</code> is a
<a href="https://doc.rust-lang.org/std/result/enum.Result.html"target="_blank" rel="noopener noreferrer"><code>Result</code> enum</a>
 before we unwrap it with <code>.expect()</code>, this means that we can
pattern match it with its variants to write a semantically equivalent version of
our code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> record <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> record {
    Ok(record) <span style="color:#f92672">=&gt;</span> record,
    Err(e) <span style="color:#f92672">=&gt;</span> panic<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Invalid record: {:?}&#34;</span>, e),
};
</code></pre></div><p>And if our census file contained, for example, an invalid second record such as:</p>
<pre><code>City,Population
Agliè,2608,
Airasca,3790, UNEXPECTED
Ala di Stura,435

...
</code></pre><p>Our program would <code>panic!</code> with the following error message:</p>
<pre><code class="language-console" data-lang="console">[INFO] Parsing CSV records
thread 'main' panicked at 'Invalid record: Error(UnequalLengths { pos: Some(Position { byte: 16, line: 2, record: 1 }), expected_len: 2, len: 3 })', src/main.rs:26:23
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre><p>Let&rsquo;s just skip to the next record if the one we are currently at is not valid:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> record <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> record {
    Ok(record) <span style="color:#f92672">=&gt;</span> record,
    Err(e) <span style="color:#f92672">=&gt;</span> {
        log::warn<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Skipping invalid record: {:?}&#34;</span>, e);
        <span style="color:#66d9ef">continue</span>;
    }
};
</code></pre></div><p>And we could even exploit the same combinator techniques we&rsquo;ve seen before, to
make the implementation a bit less verbose, thanks to the fact that
<code>reader.records()</code> returns an object that implements the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"target="_blank" rel="noopener noreferrer"><code>Iterator</code> trait</a>
,
a very powerful abstraction that offers a large set of useful methods.
And similarly to what we have done to filter valid characters with the <code>Option</code>
type, here we can use the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter_map"target="_blank" rel="noopener noreferrer"><code>Iterator::filter_map()</code></a>
 method in combination
with <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.ok"target="_blank" rel="noopener noreferrer"><code>Result::ok()</code></a>
 to filter for valid records:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">for</span> record <span style="color:#66d9ef">in</span> reader.records().filter_map(Result::ok) {
    <span style="color:#75715e">// parse valid record
</span><span style="color:#75715e"></span>}
</code></pre></div><h2 id="chapter-07---command-line-arguments">Chapter 07 - Command Line Arguments</h2>
<p>For our last chapter, let&rsquo;s improve our program so that we get rid of the
hardcoded census file path, and see how we can get an arbitrary path as a new
command line argument.</p>
<p>There are several Rust crates that allow us to build command line applications,
capable of parsing complex command line arguments while providing
useful and well presented information to the user (as an example, you should try
to implement this last chapter by using <a href="https://crates.io/crates/clap"target="_blank" rel="noopener noreferrer">clap</a>
 or <a href="https://crates.io/crates/structopt"target="_blank" rel="noopener noreferrer">structopt</a>
).
But our case is very simple, we just need to parse a single and not optional
argument, and bringing a new dependency wouldn&rsquo;t be justifiable<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup>.</p>
<p>To do that, the standard library already offers all we need with the
<a href="https://doc.rust-lang.org/std/env/fn.args.html"target="_blank" rel="noopener noreferrer"><code>std::env::args</code> function</a>
, which returns the arguments that our program was
started with. This method also returns an object that implements <code>Iterator</code>, and
therefore we can use any of the methods that the <code>Iterator</code> trait offers.</p>
<p>We are interested in the first user specified command line argument that will
contain the full path of the census file, which means that when parsing the
command line arguments, we need to skip the first one (the path of our binary).
Fortunately, we have partially seen how to do this already with the
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.nth"target="_blank" rel="noopener noreferrer"><code>Iterator::nth()</code> method</a>
 that returns an <code>Option</code> with <code>Some(Type)</code> if the
item in position <em>nth</em> exists (otherwise returns <code>None</code>):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::env;

<span style="color:#66d9ef">let</span> dataset <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> env::args().nth(<span style="color:#ae81ff">1</span>) {
    Some(path) <span style="color:#f92672">=&gt;</span> path,
    _ <span style="color:#f92672">=&gt;</span> panic<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;The path of the census file must be specified&#34;</span>),
};
</code></pre></div><p>As a final note, the underscore <code>_</code> you see in the above <code>match</code> is an identifier
that can be used to match <em>anything else</em> (i.e. any other possible enum variant),
which, in the case of a <code>Option</code> enum, is equivalent to writing <code>None</code>.</p>
<p>To run your new implementation, you can pass a command line argument to your binary
via Cargo with:</p>
<pre><code class="language-console" data-lang="console">$ cargo run -- census.csv
</code></pre><h2 id="conclusions">Conclusions</h2>
<p>We&rsquo;ve covered a lot together, and obviously there would be a lot more to cover
(for that I suggest to have a look at the <a href="https://doc.rust-lang.org/book/"target="_blank" rel="noopener noreferrer">Rust Book</a>
), but in the end we&rsquo;ve
managed to complete a nice implementation to show the <em>weirdness</em> of Benford&rsquo;s law
in less than 50 lines of code.</p>
<p>I leave you with the full code, so that you can have a single place where to
review everything we&rsquo;ve seen so far.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::{
    collections::{BTreeMap, HashMap},
    env, fs,
};

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    env_logger::init();

    <span style="color:#66d9ef">let</span> dataset <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> env::args().nth(<span style="color:#ae81ff">1</span>) {
        Some(path) <span style="color:#f92672">=&gt;</span> path,
        _ <span style="color:#f92672">=&gt;</span> panic<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;The path of the census file must be specified&#34;</span>),
    };

    log::info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Reading dataset from {}&#34;</span>, dataset);
    <span style="color:#66d9ef">let</span> file <span style="color:#f92672">=</span> fs::File::open(dataset).expect(<span style="color:#e6db74">&#34;Cannot read dataset&#34;</span>);
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> reader <span style="color:#f92672">=</span> csv::Reader::from_reader(file);

    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> frequency <span style="color:#f92672">=</span> HashMap::new();

    log::info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Parsing CSV records&#34;</span>);
    <span style="color:#66d9ef">for</span> record <span style="color:#66d9ef">in</span> reader.records().filter_map(Result::ok) {
        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(digit) <span style="color:#f92672">=</span> get_first_digit(<span style="color:#f92672">&amp;</span>record) {
            log::trace<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Found digit &#39;{}&#39; in {:?}&#34;</span>, digit, record);
            <span style="color:#66d9ef">let</span> count <span style="color:#f92672">=</span> frequency.entry(digit).or_insert(<span style="color:#ae81ff">0</span>);
            <span style="color:#f92672">*</span>count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
        } <span style="color:#66d9ef">else</span> {
            log::warn<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;No valid digit found in {:?}&#34;</span>, record);
        }
    }
    log::debug<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Frequency: {:?}&#34;</span>, frequency);

    <span style="color:#66d9ef">let</span> total: <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> frequency.values().sum();
    <span style="color:#66d9ef">let</span> percentage: <span style="color:#a6e22e">BTreeMap</span><span style="color:#f92672">&lt;</span>char, <span style="color:#66d9ef">f32</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> frequency
        .into_iter()
        .map(<span style="color:#f92672">|</span>(digit, count)<span style="color:#f92672">|</span> (digit, count <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f32</span> <span style="color:#f92672">/</span> total <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f32</span>))
        .collect();
    log::info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Percentage: {:#.2?}&#34;</span>, percentage);
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_first_digit</span>(record: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">csv</span>::StringRecord) -&gt; Option<span style="color:#f92672">&lt;</span>char<span style="color:#f92672">&gt;</span> {
    log::trace<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Parsing record: {:?}&#34;</span>, record);
    record
        .get(<span style="color:#ae81ff">1</span>)
        .and_then(<span style="color:#f92672">|</span>population<span style="color:#f92672">|</span> population.chars().next())
        .filter(<span style="color:#f92672">|</span>c<span style="color:#f92672">|</span> c.is_ascii_digit() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>c <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;0&#39;</span>)
}
</code></pre></div><p>As possible follow-up exercises, you can fork the
<a href="https://github.com/gliderkite/learn-rust-with-benford"target="_blank" rel="noopener noreferrer">learn-rust-with-benford repository</a>
 and try to implement any of the following
options:</p>
<ul>
<li>In <a href="#chapter-02---reading-the-dataset">Chapter 02</a>
, I showed you the format
(CSV) and the scheme (2 columns) of the census file used throughout the
whole post. If you decided to use the census of your own country, you
may have to deal with a different scheme or a different format. Try to
modify the program when having to deal with such differences.</li>
<li>In <a href="#chapter-03---logging">Chapter 03</a>
, we used the <code>env_logger</code> crate as our 
logger implementation. Try to find in <a href="https://crates.io/"target="_blank" rel="noopener noreferrer">crates.io</a>
 other possible
crates that you could use to replace it.</li>
<li>In <a href="#chapter-04---parsing-the-dataset">Chapter 04</a>
, we decided to deal with
strings and use the <code>char</code> type for our digit. Try to modify the program
using integers instead.</li>
<li>In <a href="#chapter-05---comparing-results">Chapter 05</a>
, we used a <code>BTreeMap</code> to both
sort our digits and store the final percentage values. Can you think of and
implement other ways to achieve the same result?</li>
<li>In <a href="#chapter-06---error-handling">Chapter 06</a>
, we decided to simply skip any
invalid record when iterating over the full set of records. What if we also
wanted to log when a record is not valid and compute the percentage of
how many invalid records were found?</li>
<li>In <a href="#chapter-07---command-line-arguments">Chapter 07</a>
, we used the function
provided by the standard library to parse the command line arguments.
There are several crates that allow the same while giving you the option
to display detailed information to the user. Can you modify the program to
make use of any of the available alternatives?</li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Please note that the reason why this law seems to yield such accurate results
is, although quite interesting, out of the scope of this post. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>By default <code>cargo build</code> will compile your project in Debug mode (dev
profile), you can enable optimizations and compile it in Release with
<code>cargo build --release</code>. You can go even further and customize your builds with
specific <a href="https://doc.rust-lang.org/book/ch14-01-release-profiles.html"target="_blank" rel="noopener noreferrer">profile settings</a>
 in your <code>Cargo.toml</code>. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>If you want to know what are the traits that are implemented for a specific
type, just look for the <code>Trait Implementations</code> section in the type documentation. <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>When the size of your project increases, the Rust compiler starts to become
slower and slower; if you just need to check whether your code is correct without
actually producing an executable you can use <code>cargo check</code> instead of using
<code>cargo build</code>, or (if you want even more useful suggestions from the compiler)
try using <a href="https://github.com/rust-lang/rust-clippy"target="_blank" rel="noopener noreferrer">clippy</a>
 with <code>cargo clippy</code>. <a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5" role="doc-endnote">
<p>The borrow checker is out of the scope of this post; for now you just need to
know that is thanks to the borrow checker that the Rust compiler can prevent
<a href="https://en.wikipedia.org/wiki/Race_condition#Data_race"target="_blank" rel="noopener noreferrer">data races</a>
 (and consequent <a href="https://en.wikipedia.org/wiki/Undefined_behavior"target="_blank" rel="noopener noreferrer">undefined behavior</a>
) at <strong>compile time</strong>. <a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6" role="doc-endnote">
<p>Dependency management is <a href="https://en.wikipedia.org/wiki/Dependency_hell"target="_blank" rel="noopener noreferrer">very, very hard</a>
. <a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
</article><section class="article author"><div class="details"><a class="item" href="https://github.com/gliderkite" target="_blank" rel="noopener noreferrer"><span class="iconfont icon-github"></span>&nbsp;gliderkite</a><a class="item" href="https://twitter.com/gliderkite" target="_blank" rel="noopener noreferrer"><span class="iconfont icon-twitter"></span>&nbsp;@gliderkite</a><a class="item" href="mailto:gliderkite@gmail.com" target="_blank" rel="noopener noreferrer"><span class="iconfont icon-email"></span>&nbsp;gliderkite@gmail.com</a></div>
</section>
</div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/posts/sr-cache/"><span class="iconfont icon-article"></span>An asynchronous self-rehydrating cache in Rust</a></p><p><a class="link" href="/posts/formicarium/"><span class="iconfont icon-article"></span>Formicarium</a></p></section></div></section><section id="footer"></section><script defer type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-e/4/LvThKH1gwzXhdbY2AsjR3rm7LHWyhIG5C0jiRfn8AN2eTN5ILeztWw0H9jmN" crossorigin="anonymous"></script>
        <script
            type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script><script src="/js/hljs.min.0799348a91dce12c6be4a73f943cfe78f181f4e6f6ec35c4af0fca1de377879f77cfab03c30f03a174d675737b5a9314.js" integrity="sha384-B5k0ipHc4Sxr5Kc/lDz&#43;ePGB9Ob27DXErw/KHeN3h593z6sDww8DoXTWdXN7WpMU"></script><script>hljs.initHighlightingOnLoad();</script></body>

</html>